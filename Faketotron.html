<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Faketotron Client - Protocol Editor (v1.4 Stab)</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<link rel="icon", type="image/png", href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYdJREFUWEftVjFuwzAMpN+QLWiWol/oLwxkzR/6j74lawD7FZ26dQiyJMjWN6iQAAoUS9lHJamXZnNM8Y68I+WOFv51C+PTP4HWDgSionv6GVa2hUDYXze0W58jSDwfQgjUdSmVO5/7QAR8PvT0/vqZSETwcRyp7/s/IxCBEonTdqBhGCS4WwpvByJAbr0QulkKD4EEzvp/P73Q6nIsfNAiBUogGy+2/uPtKxe/uhxT9UIKfgflhoK08ZiE7EAyRoMhUQLZeOx+HkEutwW8ZWzYhHrRJBmEQR+6iGRy99hZzGG2KlB2wyNlkQY5WGs7Qnw2/2xABcUi1ZQLOSR11m3nd5YBIX8gBNIIGg63POD2BULAuvvlfcAjqHPdtQNTXWBgd/WeRSS1loC6eitucloQCawEi36SIfMPx0x1oFal3gHyHpBXsRX3i9gcAekT1Af5gkQ+UucISJPppVOrtjDp/roJu/W5ioMQ0CNozTf6n1sCSXBqxFBfuAjATr4lsHUP3IJZnP0B6KuYITM8RzwAAAAASUVORK5CYII=">
<style>
  :root{--bg:#eef1f3;--panel:#fff;--bar:#cfd9eb;--field:#c6e6ee;--ink:#222;--b:#9aa5b1;--bd:#6b7a8a;--accent:#6e8fb5;--rule:#bac6d9}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px "Segoe UI",Tahoma,Arial,sans-serif;width:1200px;height:800px;overflow:hidden}
  .tabs{height:48px;display:flex;align-items:flex-end;gap:8px;padding:0 8px}
  .tab{height:36px;padding:0 18px;border:1px solid var(--b);border-bottom:none;border-radius:4px 4px 0 0;background:#f6f7f9;display:flex;align-items:center}
  .tab.active{background:#fff;font-weight:600}
  .row{display:flex;gap:12px;padding:0 12px 12px;height:calc(100% - 48px)}
  .left{width:800px;background:var(--panel);border:1px solid var(--b);display:flex;flex-direction:column}
  .right{width:360px;margin-left:auto;background:var(--panel);border:1px solid var(--b);display:flex;flex-direction:column}
  .toolbar{height:44px;background:var(--bar);border-bottom:1px solid var(--b);display:flex;align-items:center;padding:0 10px;gap:12px;justify-content: flex-end;}
  .toolbar .btn:first-child {margin-right:180px;min-width:120px;}
  .btn{min-width:85px;height:28px;border:1px solid var(--b);background:linear-gradient(#fff,#e6e9ee);border-radius:4px;cursor:pointer}
  .btn.small{min-width:75px;height:24px}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .label{font-weight:600}
  .field{height:28px;min-width:140px;border:1px solid var(--bd);background:var(--field);border-radius:3px;text-align:center;line-height:28px;padding:0 8px}
  .group-tabs{height:30px;display:flex;align-items:center;gap:3px;padding:6px 8px;background:#f3f3f3;border-bottom:1px solid var(--b);flex-wrap:wrap}
  .gtab{padding:4px 8px;border:1px solid var(--b);border-radius:4px;background:#eee;font-size:12px;cursor:pointer}
  .gtab.active{background:#fff;border-color:var(--accent)}
  .workspace{flex:1;background:#e6e6e6;margin:8px;border:1px solid var(--b);overflow:auto}

  .ph-list{background:#fff;border:1px solid var(--b)}
  .ph-row{display:grid;grid-template-columns:40px 120px 120px 1fr 120px;align-items:center;border-bottom:1px solid #dde2ea;padding:8px 10px;min-height:48px}
  .ph-row.tall{min-height:110px}
  .ph-row.header{background:#f2f5f9;font-weight:600}
  .ph-row.header div:last-child {padding-left: 50%};
  .ph-row.dragging{opacity:.6}
  .ph-actions{display:flex;flex-direction:column;gap:6px;justify-content:center;align-items:flex-end}
  .pill{display:inline-block;background:#eaf3ff;border:1px solid #8aa4c2;padding:2px 6px;border-radius:4px;font-size:12px;margin-right:6px}
  .clickable{cursor:pointer}

  .sum-grid{display:grid;grid-template-columns:repeat(4, auto);gap:6px 16px;align-items:center}
  .sum-grid .l{color:#475769}
  .sum-grid .v{background:#f3f7fb;border:1px solid #c9d3e6;border-radius:3px;padding:2px 6px}

  .right-head{padding:10px}
  .select{width:100%;height:30px;border:1px solid var(--b);border-radius:4px}
  .section{padding:8px 10px 4px}
  .rule{height:1px;background:var(--rule);margin:8px 0 12px}
  .section h5{margin:0;font-weight:600;color:#37455a}
  .file-row{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;padding:0 10px 8px}
  .file-row .btn{min-width:unset;width:100%}
  .prop{display:grid;grid-template-columns:110px 1fr auto;align-items:center;padding:6px 10px}
  .prop .input{max-width: 110px;}
  .input, textarea{border:1px solid var(--bd);background:var(--field);border-radius:3px;padding:6px}
  textarea{height:90px;resize:none}
  .ro{background:#e9eef2;text-align:center;max-width:none !important;}
  .instruction{margin-top:auto;border-top:1px solid var(--b);padding:10px;font-size:20px;color:#556;background:#f7f8fb}

  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
  .modal{width:760px;background:#4a5f73;padding:22px;border-radius:6px;box-shadow:0 8px 20px rgba(0,0,0,.35)}
  .modal-title{color:#fff;font-weight:600;text-align:center;margin:0 0 10px}
  .modal-inner{background:#f2f2f2;border:1px solid var(--bd);padding:14px}
  .vm-body{display:grid;grid-template-columns:1fr 140px;gap:10px}
  .vg-tabs{display:flex;gap:6px;margin-bottom:10px;flex-wrap:wrap}
  .vg-tab{padding:6px 10px;border:1px solid var(--b);background:#e7ebef;border-radius:4px;font-size:12px;cursor:pointer}
  .vg-tab.active{background:#fff;border-color:var(--accent)}
  .vg-col{background:#fff;border:1px solid var(--b);padding:8px;max-height:260px;overflow:auto}
  .pill-row{display:flex;align-items:center;gap:6px;margin:4px 0}
  .mini{min-width:70px;height:24px}
  .side-actions{display:flex;flex-direction:column;gap:8px}
  .footer-line{display:flex;justify-content:space-between;color:#555;font-size:12px;margin-top:6px}
  .sub{width:680px}
  .sub-wide{width:820px}
  .sub-inner{background:#d6dee6;border:1px solid var(--bd);padding:16px;border-radius:6px}
  .listbox{background:#f7f9fb;border:1px solid var(--b);max-height:360px;overflow:auto;padding:10px}
  .grid2{display:grid;grid-template-columns:160px 1fr;gap:8px;align-items:center}
</style>
</head>
<body>
  <div class="tabs">
    <div class="tab">MAIN</div>
    <div class="tab">EXPERIMENT</div>
    <div class="tab active">PROTOCOL EDITOR</div>
    <div class="tab">DATA VIEWER</div>
    <div class="tab">CONTROLS</div>
    <div class="tab">SERVICE</div>
    <div class="tab">AUTHENTICATION</div>
  </div>

  <div class="row">
    <div class="left">
      <div class="toolbar">
        <button class="btn" id="btnEditGroups">Edit Groups</button>
        <span class="label">Group duration:</span>
        <div class="field" id="groupDuration">--</div>
        <button class="btn" id="btnClearGroup" disabled>Clear Group</button>
        <button class="btn" id="btnAddPhase" disabled>Add Phase</button>
      </div>
      <div id="groupTabs" class="group-tabs" style="display:none;"></div>
      <div class="workspace" id="workspace">
        <div id="phaseArea">
          <div class="ph-list" id="phList" style="display:none">
            <div class="ph-row header"><div>#</div><div>Duration</div><div>Phase</div><div>Summary</div><div>Actions</div></div>
          </div>
          <div class="placeholder" id="blankState">Create a NEW protocol to initialize default groups.</div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="right-head"><select id="profileSel" class="select"></select></div>
      <div class="section"><div class="rule"></div><h5>Protocol File</h5></div>
      <div class="file-row">
        <button class="btn" id="btnNew">NEW</button>
        <button class="btn" id="btnErase">Erase</button>
        <button class="btn" id="btnLoad">Load..</button>
        <button class="btn" id="btnSave">Save..</button>
      </div>
      <input type="file" id="fileFyt" accept=".fyt,.FYT" style="display:none" />
      <div class="section"><div class="rule"></div><h5>Protocol Properties</h5></div>
      <div class="prop"><label>Description:</label><textarea id="desc"></textarea><div></div></div>
      <div class="prop"><label>Logic start time:</label>
        <input id="logic" class="input" placeholder="HH:MM:SS or leave blank" value="- not set -" />
        <button class="btn" id="btnEraseTime">Erase Time</button>
      </div>
      <div class="prop"><label>Repeat:</label><input id="repeat" class="input" value="Infinitely times" /><button class="btn" id="btnSetInf">Set Infinitely</button></div>
      <div class="prop"><label>Duration:</label><input id="duration" class="input ro" value="0 hours" readonly /><div></div></div>
      <div class="instruction">
        <b>Instructions: see <a href="https://solisservices.sharepoint.com/:u:/s/NPECUtrechtTeam/EZ4Ba7kzajFMphowLpJmRTwBm3qK5AQ8DlR7BXA22z4JzQ?e=1RmDUY">Tutorial Page</a></b>
        <p style="font-size:12px;">Disclaimer: This software is an independent, non-commercial imitation of certain user interface features from the Protocol Editor component of the Fytotron Client by <a href="https://psi.cz/">Photon Systems Instruments (PSI)</a>. It is provided solely for academic, educational, and research purposes. This software is not affiliated with, endorsed by, or produced by PSI. All trademarks, product names, and intellectual property rights remain the sole property of their respective owners. This imitation does not connect to, control, or operate any real instruments and must not be used in any production, clinical, agricultural, or commercial setting. Any resemblance to the original software is for educational purposes only.</p>
      </div>
    </div>
  </div>

  <!-- Group manager -->
  <div class="overlay" id="dlgGroups">
    <div class="modal">
      <h3 class="modal-title">Faketotron – Protocol Variables Management</h3>
      <div class="modal-inner">
        <div class="vg-tabs" id="vgTabs"></div>
        <div class="vm-body">
          <div>
            <div class="vg-col" id="vgList"></div>
            <div class="footer-line"><span id="vmGroupName"></span><span id="vmVarCount"></span></div>
          </div>
          <div class="side-actions">
            <button class="btn" id="btnCreateGroup">Create Group</button>
            <button class="btn" id="btnDeleteGroup">Delete Group</button>
            <button class="btn" id="btnRenameGroup">Rename Group</button>
            <button class="btn" id="btnAddVariable">Add Variable</button>
          </div>
        </div>
        <div class="dlg-buttons"><button class="btn" id="btnCloseGroups">OK</button></div>
      </div>
    </div>
  </div>

  <!-- New group / choose target / add var modals -->
  <div class="overlay" id="dlgNewGroup"><div class="modal sub"><h3 class="modal-title">New Group Of Variables</h3><div class="modal-inner sub-inner"><div class="grid2"><label>Type:</label><select id="ngType" class="select" style="height:32px"></select><label>Name:</label><input id="ngName" class="input" /></div><div class="flex-end" style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;"><button class="btn" id="ngCancel">Cancel</button><button class="btn" id="ngOK">OK</button></div></div></div></div>
  <div class="overlay" id="dlgChooseGroup"><div class="modal sub-wide"><h3 class="modal-title">Choose targed group</h3><div class="modal-inner sub-inner"><div class="listbox" id="cgList"></div><div class="flex-end" style="display:flex;justify-content:flex-end;margin-top:10px"><button class="btn" id="cgCancel">Cancel</button></div></div></div></div>
  <div class="overlay" id="dlgAddVar"><div class="modal sub-wide"><h3 class="modal-title">Choose variable(s) for group: <span id="avGroupName"></span></h3><div class="modal-inner sub-inner"><div class="listbox" id="avList"></div><div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px;"><div style="display:flex;gap:8px;"><button class="btn small" id="avAll">SELECT ALL</button><button class="btn small" id="avNone">SELECT NONE</button></div><div>All: <span id="avAllCount">0</span> | Selected: <span id="avSelCount">0</span></div></div><div class="flex-end" style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;"><button class="btn" id="avCancel">Cancel</button><button class="btn" id="avOK">OK</button></div></div></div></div>
  <div class="overlay" id="dlgWarn"><div class="modal sub"><h3 class="modal-title">Notice</h3><div class="modal-inner sub-inner"><div style="background:#f0f4f8;border:1px solid var(--b);padding:24px;text-align:center">Another group of same type doesn't exist.<br/>Create some before move variable.</div><div class="flex-end" style="display:flex;justify-content:flex-end;margin-top:12px;"><button class="btn" id="warnOK">OK</button></div></div></div></div>

  <!-- Phase editor -->
  <div class="overlay" id="dlgPhase"><div class="modal sub-wide"><h3 class="modal-title">Add / Edit Phase</h3><div class="modal-inner sub-inner"><div class="grid2">
    <label>Phase type:</label>
    <select id="phType" class="select">
      <option value="const">Constant</option>
      <option value="ramp">Ramp</option>
      <option value="sin">Sine</option>
      <option value="cloud">Cloud</option>
    </select>
    <div id="phFields" style="grid-column:1/-1"></div>
  </div>
  <div class="flex-end" style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;"><button class="btn" id="phCancel">Cancel</button><button class="btn" id="phOK">OK</button></div>
  </div></div></div>

<script>
window.addEventListener('load', function() {
    alert(
        "DISCLAIMER:\n\n" +
        "This software is an independent, non-commercial imitation of certain features " +
        "from the Protocol Editor of the Fytotron Client by Photon Systems Instruments.\n\n" +
        "It is provided solely for academic, educational, and research purposes.\n\n" +
        "This software is not affiliated with, endorsed by, or produced by Photon Systems Instruments. " +
        "It does not connect to or control any real instruments and must not be used in any production, clinical, agricultural, or commercial setting."
    );
});
/* ============================================================
   PROJECT CONSTANTS / MAPPINGS
   ============================================================ */
const TAB_ORDER=["CO2","Cool White","Deep-Red","Far-Red","Humidity","Hydroponics","Temperature"];
const INVENTORY={"CO2":["CO2"],"Cool White":["Cool White 1","Cool White 2"],"Deep-Red":["Deep-Red 1","Deep-Red 2"],"Far-Red":["Far-Red 1","Far-Red 2"],"Humidity":["Humidity"],"Hydroponics":["Hydroponics 1","Hydroponics 2"],"Temperature":["Temperature"]};
const MACHINE_VAR={"CO2":{"CO2":"CO2_Set"},"Cool White":{"Cool White 1":"CoolWhite1","Cool White 2":"CoolWhite2"},"Deep-Red":{"Deep-Red 1":"DeepRed1","Deep-Red 2":"DeepRed2"},"Far-Red":{"Far-Red 1":"FarRed1","Far-Red 2":"FarRed2"},"Humidity":{"Humidity":"Rh_Set"},"Hydroponics":{"Hydroponics 1":"Run1","Hydroponics 2":"Run2"},"Temperature":{"Temperature":"T_Set"}};
const TYPE_UNIT={"CO2":{type:"co2",unit:"ppm"},"Cool White":{type:"white",unit:"percent"},"Deep-Red":{type:"deep-red",unit:"percent"},"Far-Red":{type:"far-red",unit:"percent"},"Humidity":{type:"humidity",unit:"percent"},"Hydroponics":{type:"hydroponie",unit:""},"Temperature":{type:"temperature",unit:"celsius"}};

const RANGES={
  "CO2":{min:0,max:1000,int:true},
  "Cool White":{min:0,max:100,int:true},
  "Deep-Red":{min:0,max:100,int:true},
  "Far-Red":{min:0,max:100,int:true},
  "Humidity":{min:35,max:90,int:true},
  "Hydroponics":{min:0,max:1,int:true},
  "Temperature":{min:0,max:500,int:true,scale:10}
};
const DEF={
  const:{
    "CO2":{value:1000,duration:"01:00:00"},
    "Cool White":{value:100,duration:"01:00:00"},
    "Deep-Red":{value:100,duration:"01:00:00"},
    "Far-Red":{value:100,duration:"01:00:00"},
    "Humidity":{value:90,duration:"01:00:00"},
    "Hydroponics":{value:1,duration:"01:00:00"},
    "Temperature":{value:40,duration:"01:00:00"}
  },
  ramp:{
    "CO2":{start:0,end:1000,duration:"01:00:00"},
    "Cool White":{start:0,end:100,duration:"01:00:00"},
    "Deep-Red":{start:0,end:100,duration:"01:00:00"},
    "Far-Red":{start:0,end:100,duration:"01:00:00"},
    "Humidity":{start:35,end:90,duration:"01:00:00"},
    "Temperature":{start:10,end:40,duration:"01:00:00"}
  },
  sin:{
    "CO2":{min:0,max:1000,period:"00:10:00",phaseOffset:"00:00:00",duration:"01:00:00"},
    "Cool White":{min:0,max:100,period:"01:00:00",phaseOffset:"00:00:00",duration:"01:00:00"},
    "Deep-Red":{min:0,max:100,period:"01:00:00",phaseOffset:"00:00:00",duration:"01:00:00"},
    "Far-Red":{min:0,max:100,period:"01:00:00",phaseOffset:"00:00:00",duration:"01:00:00"},
    "Humidity":{min:35,max:90,period:"01:00:00",phaseOffset:"00:00:00",duration:"01:00:00"},
    "Temperature":{min:10,max:40,period:"01:00:00",phaseOffset:"00:00:00",duration:"01:00:00"}
  },
  cloud:{
    "CO2":{amplitude:100,offset:0,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"},
    "Cool White":{amplitude:100,offset:0,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"},
    "Deep-Red":{amplitude:100,offset:0,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"},
    "Far-Red":{amplitude:100,offset:0,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"},
    "Humidity":{amplitude:90,offset:35,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"},
    "Temperature":{amplitude:10,offset:0,cloud_density:0,cloud_position:0,cloud_duration_mean:60,cloud_duration_var:5,fluctuation_mean_ratio: (Math.round((0.15)*100)/100),fluctuation_var:10,cloud_drop_coeff:0.5,duration:"01:00:00"}
  }
};

// Fixed ramp step for all ramp phases
const RAMP_STEP = "00:00:05";
// === Profiles (external JSONs injected) ===
/* We embed provided profile JSONs here. "Fytotron" uses the base constants declared above. */

const PROFILE_JSONS = {"Fytotron": null, "Daylight": {"description": "Profile: Daylight", "repeat": 2147483647, "logic": "", "sections": [{"parts": [{"group-name": "Amber", "type": "amber", "union-tag": "fytotron", "unit": "percent", "vars": ["Amber"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}, {"group-name": "Blue", "type": "blue", "union-tag": "fytotron", "unit": "percent", "vars": ["Blue"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}, {"group-name": "CO2", "type": "co2", "union-tag": "fytotron", "unit": "ppm", "vars": ["CO2_Set"], "phases": []}, {"group-name": "Cool White", "type": "white", "union-tag": "fytotron", "unit": "percent", "vars": ["CoolWhite"], "phases": []}, {"group-name": "Cyan", "type": "cyan", "union-tag": "fytotron", "unit": "percent", "vars": ["Cyan"], "phases": [{"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}, {"group-name": "Deep-Red", "type": "deep-red", "union-tag": "fytotron", "unit": "percent", "vars": ["DeepRed"], "phases": []}, {"group-name": "Far-Red", "type": "far-red", "union-tag": "fytotron", "unit": "percent", "vars": ["FarRed"], "phases": []}, {"group-name": "Green", "type": "green", "union-tag": "fytotron", "unit": "percent", "vars": ["Green"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}, {"group-name": "Humidity", "type": "humidity", "union-tag": "fytotron", "unit": "percent", "vars": ["Rh_Set"], "phases": []}, {"group-name": "Hydroponics", "type": "hydroponie", "union-tag": "fytotron", "unit": "", "vars": ["Run1"], "phases": []}, {"group-name": "Red", "type": "red", "union-tag": "fytotron", "unit": "percent", "vars": ["Red"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}, {"group-name": "Temperature", "type": "temperature", "union-tag": "fytotron", "unit": "celsius", "vars": ["T_Set"], "phases": []}, {"group-name": "UVA", "type": "uva", "union-tag": "fytotron", "unit": "percent", "vars": ["UVA"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": 0, "max": 100, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": 0, "end": 100, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 100, "duration": "01:00:00"}]}]}]}, "Extended Temperature": {"description": "Profile: Extended Temperature", "repeat": 2147483647, "logic": "", "sections": [{"parts": [{"group-name": "CO2", "type": "co2", "union-tag": "fytotron", "unit": "ppm", "vars": ["CO2_Set"], "phases": []}, {"group-name": "Cool White", "type": "white", "union-tag": "fytotron", "unit": "percent", "vars": ["CoolWhite1", "CoolWhite2"], "phases": []}, {"group-name": "Deep-Red", "type": "deep-red", "union-tag": "fytotron", "unit": "percent", "vars": ["DeepRed1", "DeepRed2"], "phases": []}, {"group-name": "Far-Red", "type": "far-red", "union-tag": "fytotron", "unit": "percent", "vars": ["FarRed1", "FarRed2"], "phases": []}, {"group-name": "Humidity", "type": "humidity", "union-tag": "fytotron", "unit": "percent", "vars": ["Rh_Set"], "phases": []}, {"group-name": "Hydroponics", "type": "hydroponie", "union-tag": "fytotron", "unit": "", "vars": ["Run1", "Run2"], "phases": []}, {"group-name": "Temperature", "type": "temperature", "union-tag": "fytotron", "unit": "celsius", "vars": ["T_Set"], "phases": [{"type": "clouds", "duration": "01:00:00", "step": "00:00:05", "amplitude": 100, "offset": 0, "cloud_density": 0, "cloud_position": 0, "cloud_duration_mean": 60, "cloud_duration_var": 5, "fluctuation_mean_ratio": 0.15, "fluctuation_var": 10, "cloud_drop_coeff": 0.5}, {"type": "sin", "duration": "01:00:00", "step": "00:00:05", "min": -50, "max": 400, "period": "00:10:00", "phaseOffset": "00:00:00"}, {"type": "ramp", "start": -50, "end": 400, "duration": "01:00:00", "step": "00:00:05"}, {"type": "const", "value": 400, "duration": "01:00:00"}]}]}]}, "Hotel": {"description": "Profile: Hotel", "repeat": 2147483647, "logic": "", "sections": [{"parts": [{"group-name": "Cool White", "type": "white", "union-tag": "fytotron", "unit": "percent", "vars": ["CoolWhite1", "CoolWhite2", "CoolWhite3", "CoolWhite4"], "phases": []}, {"group-name": "Deep-Red", "type": "deep-red", "union-tag": "fytotron", "unit": "percent", "vars": ["DeepRed1", "DeepRed2", "DeepRed3", "DeepRed4"], "phases": []}, {"group-name": "Far-Red", "type": "far-red", "union-tag": "fytotron", "unit": "percent", "vars": ["FarRed1", "FarRed2", "FarRed3", "FarRed4"], "phases": []}]}]}};

// Snapshot base constants so we can restore 'Fytotron'
const BASE_CONSTS = {
  TAB_ORDER: JSON.parse(JSON.stringify(TAB_ORDER)),
  INVENTORY: JSON.parse(JSON.stringify(INVENTORY)),
  MACHINE_VAR: JSON.parse(JSON.stringify(MACHINE_VAR)),
  TYPE_UNIT: JSON.parse(JSON.stringify(TYPE_UNIT)),
  RANGES: JSON.parse(JSON.stringify(RANGES)),
  DEF: JSON.parse(JSON.stringify(DEF))
};
let ACTIVE_PROFILE = 'Fytotron';

function clearObject(obj){
  for(const k in obj){ delete obj[k]; }
}
function assignObject(dst, src){
  clearObject(dst);
  for(const k in src){ dst[k] = src[k]; }
}
// Build TYPE_UNIT from parts
function buildTypeUnitFromParts(parts){
  const out = {};
  parts.forEach(p=>{
    const name = p["group-name"];
    out[name] = { type:p.type, unit:p.unit || "" };
  });
  return out;
}
// Build INVENTORY and MACHINE_VAR from parts; we use machine names as display names 1:1
function buildInventoryAndMachineVar(parts){
  const inv = {};
  const mv = {};
  parts.forEach(p=>{
    const name = p["group-name"];
    const vars = (p.vars || []).slice();
    inv[name] = vars.slice();
    mv[name] = {};
    vars.forEach(v => { mv[name][v] = v; });
  });
  return {INV:inv, MV:mv};
}
// Build TAB_ORDER as group-name order
function buildTabOrderFromParts(parts){ return parts.map(p=>p["group-name"]); }

// Update RANGES for a profile; default to BASE, but ensure each group has a sensible range
function buildRangesForProfile(profileName, parts){
  const base = BASE_CONSTS.RANGES;
  const out = {};
  // start by cloning base known keys
  for(const k in base){ out[k] = JSON.parse(JSON.stringify(base[k])); }
  // ensure each part has a range; default 0–100 int for light-like groups
  parts.forEach(p=>{
    const name = p["group-name"];
    if(!out[name]){
      out[name] = {min:0,max:100,int:true};
    }
  });
  // Special: Daylight new channels (Amber, Blue, Cyan, Green, Red, UVA) -> 0–100 percent
  if(profileName==='Daylight'){
    ['Amber','Blue','Cyan','Green','Red','UVA'].forEach(n=>{
      out[n] = {min:0,max:100,int:true};
    });
  }
  return out;
}

// Build DEF from BASE and optional overrides present in profile JSON parts[].phases
function buildDefForProfile(parts){
  // clone deep
  const def = JSON.parse(JSON.stringify(BASE_CONSTS.DEF));
  parts.forEach(p=>{
    const name = p["group-name"];
    const phases = p.phases || [];
    if(phases.length===0) return;
    // For each phase type present, set that as default for this group
    phases.forEach(ph=>{
      if(!ph || !ph.type) return;
      const typ = (ph.type==='clouds') ? 'cloud' : ph.type;
      if(!def[typ]) def[typ] = {};
      if(typ==='ramp'){
        def.ramp[name] = { start:ph.start, end:ph.end, duration:ph.duration||'01:00:00' };
      }else if(typ==='sin'){
        def.sin[name] = { min:ph.min, max:ph.max, period:ph.period, phaseOffset:ph.phaseOffset, duration:ph.duration||'01:00:00' };
      }else if(typ==='cloud'){
        def.cloud[name] = {
          amplitude:ph.amplitude, offset:ph.offset,
          cloud_density:ph.cloud_density, cloud_position:ph.cloud_position,
          cloud_duration_mean:ph.cloud_duration_mean, cloud_duration_var:ph.cloud_duration_var,
          fluctuation_mean_ratio: (Math.round((ph.fluctuation_mean_ratio)*100)/100), fluctuation_var:ph.fluctuation_var,
          cloud_drop_coeff: (Math.round((ph.cloud_drop_coeff)*100)/100), duration:ph.duration||'01:00:00'
        };
      }else if(typ==='const'){
        def.const[name] = { value:ph.value, duration:ph.duration||'01:00:00' };
      }
    });
  });
  return def;
}

// Apply a profile by mutating the existing constant maps
function applyProfile(name){
  const prof = PROFILE_JSONS[name];
  ACTIVE_PROFILE = name;
  if(!prof){ // Fytotron
    // restore base consts
    TAB_ORDER.length = 0; Array.prototype.push.apply(TAB_ORDER, BASE_CONSTS.TAB_ORDER);
    assignObject(INVENTORY, BASE_CONSTS.INVENTORY);
    assignObject(MACHINE_VAR, BASE_CONSTS.MACHINE_VAR);
    assignObject(TYPE_UNIT, BASE_CONSTS.TYPE_UNIT);
    assignObject(RANGES, BASE_CONSTS.RANGES);
    assignObject(DEF, BASE_CONSTS.DEF);
  }else{
    const parts = (prof.sections && prof.sections[0] && prof.sections[0].parts) ? prof.sections[0].parts : [];
    // TAB_ORDER
    TAB_ORDER.length = 0; Array.prototype.push.apply(TAB_ORDER, buildTabOrderFromParts(parts));
    // INVENTORY & MACHINE_VAR
    const iv = buildInventoryAndMachineVar(parts);
    assignObject(INVENTORY, iv.INV);
    assignObject(MACHINE_VAR, iv.MV);
    // TYPE_UNIT
    assignObject(TYPE_UNIT, buildTypeUnitFromParts(parts));
    // RANGES (merge)
    assignObject(RANGES, buildRangesForProfile(name, parts));
    // DEF (override per provided phases)
    assignObject(DEF, buildDefForProfile(parts));
  }
  // Rebuild inverse map used by loader
  window.INV_MACHINE_VAR = invertMachineVarMap();
  // Reset protocol/groups
  protocol = {description:"",repeat:2147483647,logic:"",sections:[{parts:[]}]};
  createDefaultGroups();
  // rebuild unassigned pool (everything unassigned initially)
  unassigned = {};
  TAB_ORDER.forEach(t=>{ unassigned[t] = []; });
  activeGroupId = groups[0]?.id || null;
  vmSelectedGroupId = activeGroupId;
  refreshUI();
}

// Wire the profile selector
(function initProfileSelector(){
  const sel = document.getElementById('profileSel');
  if(!sel) return;
  sel.innerHTML='';
  Object.keys(PROFILE_JSONS).forEach(name=>{
    const opt=document.createElement('option');
    opt.value=name; opt.textContent=name;
    sel.appendChild(opt);
  });
  sel.value = ACTIVE_PROFILE;
  sel.onchange = ()=>{
    const newName = sel.value;
    if(groups.length>0){
      if(!confirm('Switch profile and reset the current protocol?')){ sel.value = ACTIVE_PROFILE; return; }
    }
    applyProfile(newName);
  };
})();




let protocol=null; let groups=[]; let unassigned={}; let activeGroupId=null; let vmSelectedGroupId=null; let insertAfterIndex=null;
const $=s=>document.querySelector(s), $$=s=>Array.from(document.querySelectorAll(s));

/* ============================================================
   UTILS / VALIDATION
   ============================================================ */

function isHHMMSSClock(v){
  const m=/^(\d{2}):(\d{2}):(\d{2})$/.exec(v||'');
  if(!m) return false;
  const H=+m[1], M=+m[2], S=+m[3];
  return H>=0 && H<24 && M>=0 && M<60 && S>=0 && S<60;
}
// Accept either D.HH:MM:SS (HH=00-23) or H+:MM:SS (unbounded hours) for user/file inputs
function isDHHMMSS(v){
  const m=/^(\d+)\.(\d{2}):(\d{2}):(\d{2})$/.exec(v||'');
  if(!m) return false;
  const D=+m[1], H=+m[2], M=+m[3], S=+m[4];
  return D>=0 && H>=0 && H<24 && M>=0 && M<60 && S>=0 && S<60;
}
function isHPlus(v){
  const m=/^(\d+):(\d{2}):(\d{2})$/.exec(v||'');
  if(!m) return false;
  const H=+m[1], M=+m[2], S=+m[3];
  return H>=0 && M>=0 && M<60 && S>=0 && S<60;
}
function isDuration(v){ return isDHHMMSS(v) || isHPlus(v); }
// Parse either format to seconds
function durationToSeconds(s){
  if(isDHHMMSS(s)){
    const m=/^(\d+)\.(\d{2}):(\d{2}):(\d{2})$/.exec(s);
    const D=+m[1], H=+m[2], M=+m[3], S=+m[4];
    return D*86400 + H*3600 + M*60 + S;
  }
  if(isHPlus(s)){
    const m=/^(\d+):(\d{2}):(\d{2})$/.exec(s);
    const H=+m[1], M=+m[2], S=+m[3];
    return H*3600 + M*60 + S;
  }
  return NaN;
}
function durationToHours(s){ const sec=durationToSeconds(s); return Number.isFinite(sec)? sec/3600 : 0; }
// Format seconds to display rule: <24h -> HH:MM:SS; >=24h -> D.HH:MM:SS
function secondsToDisplayDuration(sec){
  sec = Math.max(0, Math.floor(sec||0));
  const SS = (n)=> String(n).padStart(2,'0');
  const days = Math.floor(sec/86400);
  let rem = sec % 86400;
  const h = Math.floor(rem/3600);
  rem %= 3600;
  const m = Math.floor(rem/60);
  const s = rem % 60;
  if(days>0){
    return `${days}.${SS(h)}:${SS(m)}:${SS(s)}`;
  }else{
    return `${SS(h)}:${SS(m)}:${SS(s)}`;
  }
}
// Normalize an input duration string into the display rule, or return null if invalid
function normalizeDurationStr(str){
  const sec = durationToSeconds(str);
  if(!Number.isFinite(sec)) return null;
  return secondsToDisplayDuration(sec);
}


function intInRange(n, min, max){return Number.isInteger(n) && n>=min && n<=max;}
// Keep group ordering stable by type then name
function sortGroups(){
  groups.sort((a,b)=>{
    const ai = TAB_ORDER.indexOf(a.type), bi = TAB_ORDER.indexOf(b.type);
    if(ai!==bi) return ai-bi;
    return a.name.localeCompare(b.name);
  });
}
// Protocol is valid if each type is present and no unassigned variables remain
function isProtocolValid(){
  const hasAll = TAB_ORDER.every(t=>groups.some(g=>g.type===t));
  const noneUnassigned = Object.values(unassigned).every(a=>a.length===0);
  return hasAll && noneUnassigned;
}
function fmtVal(type,v){ if(type==='Temperature'){return (Number(v)/10).toFixed(1);} return String(v); }
function labelPhase(t){return t==='const'?'Constant':t==='ramp'?'Ramp':t==='sin'?'Sine':t==='cloud'?'Cloud':t}

/* ============================================================
   RENDER
   ============================================================ */
function refreshUI(){
  sortGroups();
  const has=groups.length>0;
  $('#groupTabs').style.display=has?'flex':'none';
  $('#blankState').style.display=has?'none':'flex';
  $('#phList').style.display=has?'block':'none';
  $('#btnClearGroup').disabled=!has;
  $('#btnAddPhase').disabled=!has;
  $('#btnSave').disabled=!protocol||!isProtocolValid();

  renderTabs();
  renderPhases();
  updateOverallDuration();   // <-- longest group duration to the right panel
  buildVM();
}

function renderTabs(){
  const bar=$('#groupTabs');bar.innerHTML='';
  groups.forEach(g=>{
    const t=document.createElement('div');
    t.className='gtab'+(g.id===activeGroupId?' active':'');
    t.textContent=g.name;
    t.onclick=()=>{activeGroupId=g.id;renderTabs();renderPhases();updateGroupDurationField();};
    bar.appendChild(t);
  });
  updateGroupDurationField();
}
function updateGroupDurationField(){
  const ag=groups.find(x=>x.id===activeGroupId);
  const hours=ag?ag.phases.reduce((s,p)=>s+durationToHours(p.duration),0):0;
  $('#groupDuration').textContent=ag?`${hours.toFixed(2)} hours`:'--';
}
function updateOverallDuration(){
  const longestHours=Math.max(0, ...groups.map(g=>g.phases.reduce((s,p)=>s+durationToHours(p.duration),0)));
  $('#duration').value = `${longestHours.toFixed(2)} hours`;
}

function summaryGrid(container, pairs){
  const g=document.createElement('div');g.className='sum-grid';
  pairs.forEach(([label,val])=>{
    const l=document.createElement('div');l.className='l';l.textContent=label;
    const v=document.createElement('div');v.className='v';v.textContent=val;
    g.appendChild(l);g.appendChild(v);
  });
  container.appendChild(g);
}
function buildSummary(varType,p){
  const wrap=document.createElement('div');
  if(p.type==='const'){
    summaryGrid(wrap, [["Value", fmtVal(varType,p.value)]]);
  } else if(p.type==='ramp'){
    summaryGrid(wrap, [["Start", fmtVal(varType,p.start)],["End", fmtVal(varType,p.end)]]);
  } else if(p.type==='sin'){
    const pairs=[["Min", fmtVal(varType,p.min)],["Max", fmtVal(varType,p.max)],["Period", p.period],["Phase Offset", p.phaseOffset]];
    summaryGrid(wrap,pairs);
  } else if(p.type==='cloud'){
    const pairs=[["Amplitude", fmtVal(varType,p.amplitude)],["Offset", fmtVal(varType,p.offset)],["Cloud Attenuation", (Number(p.cloud_drop_coeff).toFixed(2))],["Cloud Density", p.cloud_density+"%"],["Cloud Position", p.cloud_position+"%"],["Cloud Duration Mean", p.cloud_duration_mean],["Cloud Duration Var", p.cloud_duration_var],["Fluctuation Var", p.fluctuation_var],["Fluctuation Mean Ratio", p.fluctuation_mean_ratio]];
    summaryGrid(wrap,pairs);
  }
  return wrap;
}
function renderPhases(){
  const list=$('#phList');list.querySelectorAll('.ph-row.data').forEach(n=>n.remove());
  const g=groups.find(x=>x.id===activeGroupId);if(!g)return;g.phases=g.phases||[];
  g.phases.forEach((p,i)=>{
    const r=document.createElement('div');r.className='ph-row data'+((p.type==='sin'||p.type==='cloud')?' tall':'');r.draggable=true;r.dataset.idx=i;
    r.addEventListener('dragstart',e=>{r.classList.add('dragging');e.dataTransfer.setData('text/plain',i);});
    r.addEventListener('dragend',()=>r.classList.remove('dragging'));
    r.addEventListener('dragover',e=>{e.preventDefault();});
    r.addEventListener('drop',e=>{e.preventDefault();const from=parseInt(e.dataTransfer.getData('text/plain'));const to=i;reorderPhase(from,to);});

    const cIdx=document.createElement('div');cIdx.textContent=i+1;
    const cDur=document.createElement('div');cDur.className='clickable';cDur.textContent=normalizeDurationStr(p.duration||'01:00:00');cDur.onclick=()=>{insertAfterIndex=i;openEditPhase(p);} 
    const cType=document.createElement('div');cType.innerHTML=`<span class="pill">${labelPhase(p.type)}</span>`;cType.className='clickable';cType.onclick=()=>{insertAfterIndex=i;openEditPhase(p);} 
    const cSum=document.createElement('div');cSum.className='clickable';cSum.onclick=()=>{insertAfterIndex=i;openEditPhase(p);} 
    cSum.appendChild(buildSummary(g.type,p));

    const cAct=document.createElement('div');cAct.className='ph-actions';
    const addB=document.createElement('button');addB.className='btn small';addB.textContent='add below';addB.onclick=()=>{insertAfterIndex=i;openAddPhase();};
    const del=document.createElement('button');del.className='btn small';del.textContent='remove';del.onclick=()=>{g.phases.splice(i,1);renderPhases();updateGroupDurationField();updateOverallDuration();};
    cAct.appendChild(del);cAct.appendChild(addB);

    r.appendChild(cIdx);r.appendChild(cDur);r.appendChild(cType);r.appendChild(cSum);r.appendChild(cAct);
    list.appendChild(r);
  });
}
function reorderPhase(from,to){const g=groups.find(x=>x.id===activeGroupId);if(!g)return;const item=g.phases.splice(from,1)[0];g.phases.splice(to,0,item);renderPhases();}

/* ============================================================
   VARIABLE MANAGER
   ============================================================ */
function buildVM(){const tabs=$('#vgTabs'),list=$('#vgList');if(!tabs||!list)return;tabs.innerHTML='';groups.forEach(g=>{const b=document.createElement('div');b.className='vg-tab'+(g.id===vmSelectedGroupId?' active':'');b.textContent=g.name;b.onclick=()=>{vmSelectedGroupId=g.id;buildVM();};tabs.appendChild(b);});if(!vmSelectedGroupId&&groups.length)vmSelectedGroupId=groups[0].id;const g=groups.find(x=>x.id===vmSelectedGroupId);list.innerHTML='';if(g){const title=document.createElement('div');title.textContent=g.name;title.style.fontWeight='600';title.style.margin='6px 0';list.appendChild(title);if(g.vars.length===0){const empty=document.createElement('div');empty.style.textAlign='center';empty.style.color='#666';empty.style.padding='20px 0';empty.textContent='None assigned variables';list.appendChild(empty);}g.vars.forEach(v=>{const row=document.createElement('div');row.className='pill-row';const pill=document.createElement('span');pill.className='pill';pill.textContent=v;row.appendChild(pill);const rm=document.createElement('button');rm.className='btn small';rm.textContent='Remove';rm.onclick=()=>{removeVarFromGroup(g.id,v);};const mv=document.createElement('button');mv.className='btn small';mv.textContent='Move to';mv.onclick=()=>{chooseTargetGroup(g,v);};row.appendChild(rm);row.appendChild(mv);list.appendChild(row);});}updateVMFooter(g);} 
function updateVMFooter(g){$('#vmGroupName').textContent='Actual group name:  '+(g?g.name:'-');$('#vmVarCount').textContent='Number of variables:  '+(g?g.vars.length:0);} 
function removeVarFromGroup(groupId,varName){const g=groups.find(x=>x.id===groupId);if(!g)return;g.vars=g.vars.filter(n=>n!==varName);unassigned[g.type].push(varName);refreshUI();}
function chooseTargetGroup(sourceGroup,varName){const candidates=groups.filter(g=>g.type===sourceGroup.type&&g.id!==sourceGroup.id);if(candidates.length===0){$('#dlgWarn').style.display='flex';return;}const box=$('#cgList');box.innerHTML='';candidates.forEach(g=>{const b=document.createElement('button');b.className='btn';b.textContent=g.name;b.style.minWidth='140px';b.style.margin='6px';b.onclick=()=>{moveVar(sourceGroup,g,varName);$('#dlgChooseGroup').style.display='none';};box.appendChild(b);});$('#dlgChooseGroup').style.display='flex';}
function moveVar(from,to,varName){from.vars=from.vars.filter(n=>n!==varName);if(!to.vars.includes(varName))to.vars.push(varName);refreshUI();}

$('#btnCreateGroup').onclick=()=>{const g=groups.find(x=>x.id===vmSelectedGroupId)||groups[0];const sel=$('#ngType');sel.innerHTML='';TAB_ORDER.forEach(t=>{const o=document.createElement('option');o.value=t;o.textContent=t;sel.appendChild(o);});$('#ngType').value=g?g.type:TAB_ORDER[0];$('#ngName').value=(g?g.type:TAB_ORDER[0])+' 2';$('#dlgNewGroup').style.display='flex';};
$('#btnDeleteGroup').onclick=()=>{const g=groups.find(x=>x.id===vmSelectedGroupId);if(!g)return;g.vars.forEach(v=>unassigned[g.type].push(v));groups=groups.filter(x=>x.id!==g.id);vmSelectedGroupId=groups.find(x=>x.type===g.type)?.id||groups[0]?.id||null;refreshUI();};
$('#btnRenameGroup').onclick=()=>{const g=groups.find(x=>x.id===vmSelectedGroupId);if(!g)return;const nn=prompt('Rename Group',g.name);if(!nn)return;g.name=nn.trim();refreshUI();};
$('#btnAddVariable').onclick=()=>{const g=groups.find(x=>x.id===vmSelectedGroupId);if(!g)return;const pool=unassigned[g.type];if(pool.length===0){alert('No unassigned variable for this type.');return;}$('#avGroupName').textContent=g.name;buildAddVarList(g.type);$('#dlgAddVar').style.display='flex';};
function buildAddVarList(type){const list=$('#avList');list.innerHTML='';const items=unassigned[type].slice();items.forEach(name=>{const row=document.createElement('div');row.style.margin='6px 0';const cb=document.createElement('input');cb.type='checkbox';cb.value=name;cb.onchange=updateSelCount;row.appendChild(cb);const pill=document.createElement('span');pill.className='pill';pill.textContent=name+'  ('+type+')';row.appendChild(pill);list.appendChild(row);});$('#avAllCount').textContent=items.length;updateSelCount();}
function updateSelCount(){const n=$$('#avList input[type="checkbox"]:checked').length;$('#avSelCount').textContent=n;}
$('#avAll').onclick=()=>{$$('#avList input[type="checkbox"]').forEach(cb=>cb.checked=true);updateSelCount();};
$('#avNone').onclick=()=>{$$('#avList input[type="checkbox"]').forEach(cb=>cb.checked=false);updateSelCount();};
$('#avCancel').onclick=()=> $('#dlgAddVar').style.display='none';
$('#avOK').onclick=()=>{const g=groups.find(x=>x.id===vmSelectedGroupId);if(!g)return;const chosen=$$('#avList input[type="checkbox"]:checked').map(cb=>cb.value);if(chosen.length===0){$('#dlgAddVar').style.display='none';return;}unassigned[g.type]=unassigned[g.type].filter(v=>!chosen.includes(v));chosen.forEach(v=>{if(!g.vars.includes(v))g.vars.push(v);});$('#dlgAddVar').style.display='none';refreshUI();};
$('#ngCancel').onclick=()=> $('#dlgNewGroup').style.display='none';
$('#ngOK').onclick=()=>{const type=$('#ngType').value;const name=($('#ngName').value||'').trim()||type;const g={id:crypto.randomUUID(),type,name,vars:[],phases:[]};groups.push(g);sortGroups();vmSelectedGroupId=g.id;$('#dlgNewGroup').style.display='none';refreshUI();};
$('#cgCancel').onclick=()=> $('#dlgChooseGroup').style.display='none';
$('#warnOK').onclick=()=> $('#dlgWarn').style.display='none';
$('#btnCloseGroups').onclick=()=>{groups=groups.filter(g=>g.vars&&g.vars.length>0);if(!groups.find(x=>x.id===vmSelectedGroupId))vmSelectedGroupId=groups[0]?.id||null;refreshUI();$('#dlgGroups').style.display='none';};

/* ============================================================
   PHASES: ADD / EDIT / REMOVE
   ============================================================ */
function openAddPhase(){const g=groups.find(x=>x.id===activeGroupId);if(!g)return;const typeName=g.type;const sel=$('#phType');Array.from(sel.options).forEach(o=>{o.disabled=(typeName==='Hydroponics' && o.value!=='const');});sel.value=(typeName==='Hydroponics')?'const':'const';buildPhaseFields(typeName, sel.value);sel.onchange=()=> buildPhaseFields(typeName, sel.value);$('#dlgPhase').dataset.mode='add';$('#dlgPhase').style.display='flex';}
function openEditPhase(ph){const g=groups.find(x=>x.id===activeGroupId);if(!g)return;const typeName=g.type;const sel=$('#phType');Array.from(sel.options).forEach(o=>{o.disabled=(typeName==='Hydroponics' && o.value!=='const');});sel.value=ph.type;buildPhaseFields(typeName, sel.value);if(ph.type==='const'){ $('#phVal').value=fmtForEdit(typeName, ph.value); }if(ph.type==='ramp'){ $('#phStart').value=fmtForEdit(typeName, ph.start); $('#phEnd').value=fmtForEdit(typeName, ph.end); 
    const stepVal = (ph.step || RAMP_STEP);
    const stepEl = $('#phStep'); if(stepEl){ stepEl.value = stepVal; }
    }
    if(ph.type==='cloud'){ const stepEl=$('#phStep'); if(stepEl){ stepEl.value = (ph.step || RAMP_STEP);} const dropEl=$('#phDrop'); if(dropEl){ /* keep user/set value */ } }
    if(ph.type==='sin'){ const stepEl=$('#phStep'); if(stepEl){ stepEl.value = (ph.step || RAMP_STEP);} }
    if(ph.type==='sin'){ $('#phMin').value=fmtForEdit(typeName, ph.min); $('#phMax').value=fmtForEdit(typeName, ph.max); $('#phPeriod').value=ph.period; $('#phOffset').value=ph.phaseOffset; }if(ph.type==='cloud'){ $('#phAmp').value=fmtForEdit(typeName, ph.amplitude); $('#phOff').value=fmtForEdit(typeName, ph.offset); $('#phDen').value=ph.cloud_density; $('#phPos').value=ph.cloud_position; $('#phCMean').value=ph.cloud_duration_mean; $('#phCVar').value=ph.cloud_duration_var; $('#phFR').value=ph.fluctuation_mean_ratio; $('#phFV').value=ph.fluctuation_var; $('#phDrop').value = (Number(ph.cloud_drop_coeff).toFixed(2)); }$('#phDur').value=ph.duration;$('#dlgPhase').dataset.mode='edit'; $('#dlgPhase').dataset.editIndex=insertAfterIndex;$('#dlgPhase').style.display='flex';}
function fmtForEdit(varType,val){ if(varType==='Temperature'){ return (Number(val)/10).toFixed(1); } return String(val);}


function buildPhaseFields(varType,phType){
  const wrap=$('#phFields');wrap.innerHTML='';
  const range=RANGES[varType];
  // Local override: for Humidity + Cloud, amplitude/offset must be 0–100
  const effRange = (phType==='cloud' && varType==='Humidity') ? {min:0,max:100,int:true} : range;

  const hint=(text)=>`<div style="grid-column:1/-1;color:#566;font-size:12px;margin-top:2px">${text}</div>`;
  const f=(label,id,value,placeholder='')=>`<label for="${id}">${label}:</label><input id="${id}" class="input" value="${value}" placeholder="${placeholder}">`;
  const d=DEF[phType][varType];
  if(phType==='const'){
    wrap.innerHTML=`<div class="grid2">${f('Value', 'phVal', d.value)}${f('Duration', 'phDur', d.duration, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}</div>` + hint(`Range ${range.min}–${range.max}${varType==='Temperature'?' (allow 0.1 steps; stored ×10)':''}`);
  }else if(phType==='ramp'){
    wrap.innerHTML=`<div class="grid2">${f('Start', 'phStart', d.start)}${f('End', 'phEnd', d.end)}${f('Duration', 'phDur', d.duration, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Step (fixed)', 'phStep', RAMP_STEP, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}</div>` + hint(`Range ${range.min}–${range.max}${varType==='Temperature'?' (allow 0.1 steps; stored ×10)':''}`);
  }else if(phType==='sin'){
    wrap.innerHTML=`<div class="grid2">${f('Duration', 'phDur', d.duration, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Step (fixed)', 'phStep', RAMP_STEP, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Min', 'phMin', d.min)}${f('Max', 'phMax', d.max)}${f('Period', 'phPeriod', d.period, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Phase Offset', 'phOffset', d.phaseOffset, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}</div>` + hint(`Min/Max in ${range.min}–${range.max}${varType==='Temperature'?' (allow 0.1 steps; stored ×10)':''}`);
  }else if(phType==='cloud'){
    wrap.innerHTML=`<div class="grid2">${f('Duration', 'phDur', d.duration, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Step (fixed)', 'phStep', RAMP_STEP, 'HH:MM:SS (or D.HH:MM:SS for >24h)')}${f('Amplitude', 'phAmp', d.amplitude)}${f('Offset', 'phOff', d.offset)}${f('Cloud Density', 'phDen', d.cloud_density)}${f('Cloud Position', 'phPos', d.cloud_position)}${f('Cloud Duration Mean (min)', 'phCMean', d.cloud_duration_mean)}${f('Cloud Duration Var', 'phCVar', d.cloud_duration_var)}${f('Fluctuation Mean Ratio', 'phFR', d.fluctuation_mean_ratio)}${f('Fluctuation Var', 'phFV', d.fluctuation_var)}${f('Cloud Attenuation', 'phDrop', (typeof d.cloud_drop_coeff==='number'? d.cloud_drop_coeff.toFixed(2): d.cloud_drop_coeff))}</div>` + hint(`Density/Position: integers 0–100. Amplitude/Offset within ${effRange.min}–${effRange.max}${varType==='Temperature'?' (allow 0.1 steps; stored ×10)':''}`);
  }
  // lock step & cloud drop fields (visible but uneditable)
  setTimeout(()=>{const st=$('#phStep'); if(st){ st.readOnly=true; st.classList.add('ro'); }},0);}
  // lock step field if present
  setTimeout(()=>{const st=$('#phStep'); if(st){ st.readOnly=true; st.classList.add('ro'); }},0);




function readPhaseFromForm(varType){
  const t=$('#phType').value;const rng=RANGES[varType];
  const tempDecimalAllowed=(varType==='Temperature');
  const asNumber=(raw)=>{const n=Number(raw);return Number.isFinite(n)?n:NaN;};
  const clampCheck=(raw,min,max,{requireInt=true}={})=>{
    const n=asNumber(raw);
    if(!Number.isFinite(n)) return {ok:false,msg:'Not a number'};
    if(requireInt && !Number.isInteger(n)) return {ok:false,msg:'Must be an integer'};
    if(n<min||n>max) return {ok:false,msg:`Out of range (${min}-${max})`};
    return {ok:true,val:n};
  };
  const durRaw=$('#phDur').value||'01:00:00';
  const dur = normalizeDurationStr(durRaw);
  if(!dur){ alert('Duration must be HH:MM:SS or D.HH:MM:SS (e.g., 05:07:09 or 1.05:07:09)'); return null; }


  if(t==='const'){
    let res=clampCheck($('#phVal').value,rng.min,rng.max,{requireInt:!tempDecimalAllowed});
    if(!res.ok){ alert('Value: '+res.msg); return null; }
    let val=res.val; if(tempDecimalAllowed&&rng.scale) val=Math.round(val*rng.scale); else if(rng.scale) val*=rng.scale;
    return {type:'const',value:val,duration:dur};
  }else if(t==='ramp'){
    let sC=clampCheck($('#phStart').value,rng.min,rng.max,{requireInt:!tempDecimalAllowed}); if(!sC.ok){alert('Start: '+sC.msg);return null;}
    let eC=clampCheck($('#phEnd').value,rng.min,rng.max,{requireInt:!tempDecimalAllowed}); if(!eC.ok){alert('End: '+eC.msg);return null;}
    let s=sC.val,e=eC.val; if(tempDecimalAllowed&&rng.scale){s=Math.round(s*rng.scale);e=Math.round(e*rng.scale);} else if(rng.scale){s*=rng.scale;e*=rng.scale;}
    const step=(($('#phStep')?.value)||RAMP_STEP);
    return {type:'ramp',start:s,end:e,duration:dur,step:step};
  }else if(t==='sin'){
    let mnC=clampCheck($('#phMin').value,rng.min,rng.max,{requireInt:!tempDecimalAllowed}); if(!mnC.ok){alert('Min: '+mnC.msg);return null;}
    let mxC=clampCheck($('#phMax').value,rng.min,rng.max,{requireInt:!tempDecimalAllowed}); if(!mxC.ok){alert('Max: '+mxC.msg);return null;}
    const periodRaw=$('#phPeriod').value||'01:00:00'; const period=normalizeDurationStr(periodRaw); if(!period){alert('Period must be HH:MM:SS or D.HH:MM:SS');return null;}
    const offsetRaw=$('#phOffset').value||'00:00:00'; const offset=normalizeDurationStr(offsetRaw); if(!offset){alert('Phase Offset must be HH:MM:SS or D.HH:MM:SS');return null;}
    let mn=mnC.val,mx=mxC.val; if(tempDecimalAllowed&&rng.scale){mn=Math.round(mn*rng.scale);mx=Math.round(mx*rng.scale);} else if(rng.scale){mn*=rng.scale;mx*=rng.scale;}
    const step=(($('#phStep')?.value)||RAMP_STEP);
    // Order will be enforced in buildParts
    return {type:'sin',min:mn,max:mx,period:period,phaseOffset:offset,duration:dur,step:step};
  }else if(t==='cloud'){
    // Local override for humidity clouds
    const rngEff = (varType==='Humidity') ? {min:0,max:100,int:true,scale:rng.scale} : rng;
    const den=parseInt($('#phDen').value,10); if(!intInRange(den,0,100)){alert('Cloud density must be an integer 0-100');return null;}
    const pos=parseInt($('#phPos').value,10); if(!intInRange(pos,0,100)){alert('Cloud position must be an integer 0-100');return null;}
    let ampC=clampCheck($('#phAmp').value,rngEff.min,rngEff.max,{requireInt:!tempDecimalAllowed}); if(!ampC.ok){alert('Amplitude: '+ampC.msg);return null;}
    let offC=clampCheck($('#phOff').value,rngEff.min,rngEff.max,{requireInt:!tempDecimalAllowed}); if(!offC.ok){alert('Offset: '+offC.msg);return null;}
    let amp=ampC.val, off=offC.val; if(tempDecimalAllowed&&rngEff.scale){amp=Math.round(amp*rngEff.scale);off=Math.round(off*rngEff.scale);} else if(rngEff.scale){amp*=rngEff.scale;off*=rngEff.scale;}
    const cMean=Number($('#phCMean').value); if(!Number.isInteger(cMean)){alert('Cloud duration mean must be an integer');return null;};
    const cVar=Number($('#phCVar').value); if(!Number.isInteger(cVar)){alert('Cloud duration var must be an integer');return null;};
    const fmr=Number($('#phFR').value); if(!Number.isFinite(fmr)){alert('Fluctuation mean ratio must be a number');return null;}; const __fmr_round= Math.round(fmr*100)/100; const fmr_rounded = __fmr_round;
    const fv=Number($('#phFV').value); if(!Number.isInteger(fv)){alert('Fluctuation var must be an integer');return null;};
    // Cloud Attenuation is user-controlled; round to two decimals
const drop = Math.round(Number($('#phDrop').value)*100)/100;
    const step=(($('#phStep')?.value)||RAMP_STEP);
    return {type:'cloud',amplitude:amp,offset:off,cloud_density:den,cloud_position:pos,cloud_duration_mean:cMean,cloud_duration_var:cVar,fluctuation_mean_ratio:(typeof fmr_rounded!=='undefined'? fmr_rounded : fmr),fluctuation_var:fv,cloud_drop_coeff: (Math.round((drop)*100)/100),duration:dur,step:step};
  }
  return null;
}


$('#btnAddPhase').onclick=()=>{insertAfterIndex=null;openAddPhase();};
$('#phCancel').onclick=()=> $('#dlgPhase').style.display='none';
$('#phOK').onclick=()=>{const g=groups.find(x=>x.id===activeGroupId);if(!g)return;const varType=g.type;const ph=readPhaseFromForm(varType); if(!ph) return; if($('#dlgPhase').dataset.mode==='edit'){ const idx=parseInt($('#dlgPhase').dataset.editIndex,10); g.phases.splice(idx,1,ph); } else { if(insertAfterIndex==null){g.phases.push(ph);}else{g.phases.splice(insertAfterIndex+1,0,ph);} } $('#dlgPhase').style.display='none'; renderPhases(); updateGroupDurationField(); updateOverallDuration(); };

/* ============================================================
   EXPORT: JSON & FYT
   ============================================================ */

/**
 * IMPORTANT — FYT header calculation (verified against machine files):
 * Let L = total file length in bytes (including 24-byte header, JSON with CRLF, and trailer IF Description is empty).
 * Let T = L + 104.
 * Let q = floor(T / 128).
 * hi = q - 1
 * lo = (T % 128) + 128
 * The two stored header bytes at positions 22–23 (zero-based) are: (lo, hi) in little-endian.
 *
 * SPECIAL REMARK ON LENGTH:
 * - The JSON must be serialized with CRLF line endings and NO extra newline at the end.
 * - Inside the JSON, "description" must be "" (the human description is appended as trailer).
 * - Trailer is a single 0x00 byte if description is empty; otherwise, trailer is raw UTF‑8 description bytes.
 * - L must include: 24-byte fixed header + JSON bytes + 1 if description is empty.
 * - L must NOT include the description content and its length marker if the description is none empty.
 */
const FIXED_HEADER_PREFIX = [
  0x11,0x46,0x79,0x74,0x6f,0x74,0x72,0x6f,0x6e,0x20,0x50,0x72,0x6f,0x74,0x6f,0x63,
  0x6f,0x6c,0x01,0x00,0x00,0x00,  // bytes 0..21 static
  0x00,0x00                        // bytes 22..23 will be filled by formula
];
function encodeUTF8(str){return new TextEncoder().encode(str);}
function formatJsonCRLF(obj){
  // CRLF, no trailing CRLF on last line, mirroring the python helper.
  return JSON.stringify(obj,null,2).split("\n").map((l,i,a)=> i<a.length-1? l+"\r\n" : l).join("");
}
function computeHeaderBytes(totalLen){
  const T = totalLen + 104;
  const q = Math.floor(T / 128);
  const hi = q - 1;
  const lo = (T % 128) + 128;
  return [lo & 0xFF, hi & 0xFF];
}
function downloadBytes(name, bytes){
  const blob=new Blob([bytes],{type:'application/octet-stream'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=name;a.click();URL.revokeObjectURL(a.href);
}
function downloadText(name, text, mime='application/json'){
  const a=document.createElement('a');
  a.href='data:'+mime+';charset=utf-8,'+encodeURIComponent(text);
  a.download=name; a.click();
}

function displayVarToMachine(type, display){return MACHINE_VAR[type][display]||display.replace(/\s+/g,'');}
function buildParts(){const parts=[];groups.forEach(g=>{const tu=TYPE_UNIT[g.type];const machineVars=(g.vars||[]).map(v=>displayVarToMachine(g.type,v));
  const fixedPhases = (g.phases||[]).map(p=>{
    if(!p||!p.type) return p;
    if(p.type==='ramp'){
      const {start,end,duration,step}=p;
      return {type:'ramp',duration:normalizeDurationStr(duration||'01:00:00'),step:normalizeDurationStr(step||RAMP_STEP),start:start,end:end};
    } else if(p.type==='cloud' || p.type==='clouds'){
      // Force type 'clouds' and key order, fixed step and drop coeff
      const duration = normalizeDurationStr(p.duration||'01:00:00');
      const step = normalizeDurationStr(p.step||RAMP_STEP);
      return {
        type:'clouds',
        duration:duration,
        step:step,
        amplitude:p.amplitude,
        offset:p.offset,
        cloud_density:p.cloud_density,
        cloud_position:p.cloud_position,
        cloud_duration_mean:p.cloud_duration_mean,
        cloud_duration_var:p.cloud_duration_var,
        fluctuation_mean_ratio: (Math.round((p.fluctuation_mean_ratio)*100)/100),
        fluctuation_var:p.fluctuation_var,
        cloud_drop_coeff: (Math.round((p.cloud_drop_coeff)*100)/100)
      };
    } else if(p.type==='sin'){
      const duration = normalizeDurationStr(p.duration||'01:00:00');
      const step = normalizeDurationStr(p.step||RAMP_STEP);
      return {
        type:'sin',
        duration:duration,
        step:step,
        min:p.min,
        max:p.max,
        period: normalizeDurationStr(p.period||'01:00:00'),
        phaseOffset: normalizeDurationStr(p.phaseOffset||'00:00:00')
      };
    }
    return p;
  });
  parts.push({"group-name":g.name,type:tu.type,"union-tag":"fytotron",unit:tu.unit,vars:machineVars,phases:fixedPhases});});return parts;}
function buildProtocolJson(){
  const desc=$('#desc').value||"";
  let logicVal=$('#logic').value.trim(); if(logicVal==='- not set -') logicVal='';
  if(logicVal!=='' && !isHHMMSSClock(logicVal)){alert('Logic start time must be HH:MM:SS or left blank'); return null;}
  const repRaw=$('#repeat').value.trim(); let repeat=2147483647;
  if(repRaw && repRaw!=='Infinitely times'){ const n=parseInt(repRaw,10); if(!Number.isNaN(n)&&n>0) repeat=n; }
  return {description:desc,repeat:repeat,logic:logicVal,sections:[{parts:buildParts()}]};
}

function encodeULEB128(n){
  const out=[];
  do {
    let byte = n & 0x7F;
    n >>>= 7;
    if(n !== 0) byte |= 0x80;
    out.push(byte);
  } while(n !== 0);
  return new Uint8Array(out);
}
function decodeULEB128(u8, offset){
  let result = 0, shift = 0, pos = offset;
  while(true){
    const byte = u8[pos++];
    result |= (byte & 0x7F) << shift;
    if((byte & 0x80) === 0) break;
    shift += 7;
  }
  return { value: result, next: pos };
}

function buildFytBinary(data){
  // JSON (description must be empty inside the JSON)
  const jsonCRLF = formatJsonCRLF({
    description:"",
    repeat:data.repeat,
    logic:data.logic,
    sections:data.sections
  });
  const jsonBytes = encodeUTF8(jsonCRLF);

  // Trailer = [ULEB128(descLen)] + [desc bytes]
  const descBytes = encodeUTF8(data.description || "");
  const lenBytes = encodeULEB128(descBytes.length);
  const trailer  = new Uint8Array(lenBytes.length + descBytes.length);
  trailer.set(lenBytes, 0);
  trailer.set(descBytes, lenBytes.length);

  // Header bytes 22–23 MUST NOT depend on description length.
  // Compute them from header+JSON only.
  const header = new Uint8Array(FIXED_HEADER_PREFIX); // 24 bytes template
  const lenForHeader = header.length + jsonBytes.length; // exclude trailer
  const [lo, hi] = computeHeaderBytes(lenForHeader);
  header[22] = lo; header[23] = hi;

  // Final file = header + JSON + trailer (we still write the trailer bytes)
  const totalLen = header.length + jsonBytes.length + trailer.length;
  const out = new Uint8Array(totalLen);
  out.set(header, 0);
  out.set(jsonBytes, header.length);
  out.set(trailer, header.length + jsonBytes.length);
  return out;
}

/* ============================================================
   BUTTONS / WIRES
   ============================================================ */
$('#btnNew').onclick=()=>{protocol={description:"",repeat:2147483647,logic:"",sections:[{parts:[]}]};unassigned={};TAB_ORDER.forEach(t=>unassigned[t]=[]);createDefaultGroups();refreshUI();$('#dlgGroups').style.display='flex';};
$('#btnErase').onclick=()=>{if(!confirm('Erase current protocol?'))return;protocol=null;groups=[];activeGroupId=null;unassigned={};refreshUI();};
$('#btnEraseTime').onclick=()=> $('#logic').value='- not set -';
$('#btnSetInf').onclick=()=> $('#repeat').value='Infinitely times';
$('#btnEditGroups').onclick=()=>{if(!protocol){alert('Create a NEW protocol first.');return;}$('#dlgGroups').style.display='flex';buildVM();};

// Clear Group: remove all phases of current group
$('#btnClearGroup').onclick=()=>{
  const g=groups.find(x=>x.id===activeGroupId);
  if(!g) return;
  if(!confirm(`Clear all phases in "${g.name}"?`)) return;
  g.phases = [];
  renderPhases();
  updateGroupDurationField();
  updateOverallDuration();
};


// ===== LOAD FYT =====
function bytesToString(u8){ return new TextDecoder().decode(u8); }
function stringToBytes(s){ return new TextEncoder().encode(s); }

function parseFytBytes(u8){
  if(u8.length < 24) throw new Error('File too small to be a FYT.');

  // (optional) prefix & header check — keep as-is
  for(let i=0;i<22;i++){
    if(u8[i] !== FIXED_HEADER_PREFIX[i]){ console.warn('Header prefix mismatch at', i); break; }
  }
  const [lo, hi] = computeHeaderBytes(/* we can use u8.length or skip check */ u8.length);
  if(u8[22]!== (lo&0xFF) || u8[23]!== (hi&0xFF)){ console.warn('Validation bytes differ.'); }

  // Body bytes
  const body = u8.subarray(24);

  // Find last '}' byte (0x7d) to delimit JSON
  let jsonEnd = -1;
  for(let i=body.length-1;i>=0;i--){ if(body[i]===0x7d){ jsonEnd = i; break; } }
  if(jsonEnd === -1) throw new Error('Could not locate JSON body inside FYT.');

  // Decode JSON (normalize CRLF -> LF for JS parser)
  const jsonText = new TextDecoder().decode(body.subarray(0, jsonEnd+1)).replace(/\r\n/g, '\n');
  let data;
  try{ data = JSON.parse(jsonText); }
  catch(e){ console.error('JSON parse error:', e, jsonText); throw new Error('Invalid JSON inside FYT.'); }

  // Trailer: ULEB128 length + description bytes
  const trailer = body.subarray(jsonEnd+1);
  let desc = "";
  if(trailer.length){
    const { value: dlen, next: afterLen } = decodeULEB128(trailer, 0);
    const end = afterLen + dlen;
    if(end > trailer.length) throw new Error('Corrupted FYT trailer length.');
    desc = new TextDecoder().decode(trailer.subarray(afterLen, end));
  }

  data.description = desc;
  return data;
}


function machineToDisplayType(machineType){
  for(const disp in TYPE_UNIT){
    if(TYPE_UNIT[disp].type === machineType) return disp;
  }
  return null;
}
function invertMachineVarMap(){
  const inv = {};
  for(const disp in MACHINE_VAR){
    const perType = MACHINE_VAR[disp];
    inv[disp] = {};
    for(const k in perType){
      inv[disp][perType[k]] = k; // machine -> display
    }
  }
  return inv;
}
const INV_MACHINE_VAR = invertMachineVarMap();

function buildGroupsFromLoaded(data){
  const parts = (data.sections && data.sections[0] && data.sections[0].parts) ? data.sections[0].parts : [];
  const newGroups = [];
  const assigned = {}; TAB_ORDER.forEach(t=>assigned[t]=new Set());

  parts.forEach(part=>{
    const dispType = machineToDisplayType(part.type) || part.type;
    const name = part["group-name"] || dispType;
    const varsMachine = part.vars || [];
    const dispVars = varsMachine.map(mv => (INV_MACHINE_VAR[dispType] && INV_MACHINE_VAR[dispType][mv]) ? INV_MACHINE_VAR[dispType][mv] : mv);
    dispVars.forEach(v => assigned[dispType]?.add(v));

    const rawPhases = part.phases || [];
    const phases = rawPhases.map(p=>{
      if(!p || !p.type) return p;
      if(p.type === 'clouds'){ // normalize to 'cloud' internally
        return {
          type:'cloud',
          duration: normalizeDurationStr(p.duration||'01:00:00'),
          step: normalizeDurationStr(p.step||RAMP_STEP),
          amplitude: p.amplitude,
          offset: p.offset,
          cloud_density: p.cloud_density,
          cloud_position: p.cloud_position,
          cloud_duration_mean: p.cloud_duration_mean,
          cloud_duration_var: p.cloud_duration_var,
          fluctuation_mean_ratio: (Math.round((p.fluctuation_mean_ratio)*100)/100),
          fluctuation_var: p.fluctuation_var,
          cloud_drop_coeff: (Math.round((p.cloud_drop_coeff)*100)/100)
        };
      } else if(p.type === 'ramp'){
        return {
          type:'ramp',
          start:p.start, end:p.end,
          duration: normalizeDurationStr(p.duration||'01:00:00'),
          step: normalizeDurationStr(p.step||RAMP_STEP)
        };
      } else if(p.type === 'sin'){
        return {
          type:'sin',
          duration: normalizeDurationStr(p.duration||'01:00:00'),
          step: normalizeDurationStr(p.step||RAMP_STEP),
          min:p.min, max:p.max,
          period: normalizeDurationStr(p.period||'01:00:00'),
          phaseOffset: normalizeDurationStr(p.phaseOffset||'00:00:00')
        };
      } else if(p.type === 'const'){
        return { type:'const', value:p.value, duration: normalizeDurationStr(p.duration||'01:00:00') };
      }
      return p;
    });

    newGroups.push({ id:crypto.randomUUID(), type:dispType, name, vars:dispVars, phases });
  });

  // Build unassigned pool for each type
  const newUnassigned = {};
  TAB_ORDER.forEach(t=>{
    const all = INVENTORY[t].slice();
    const used = assigned[t] ? Array.from(assigned[t]) : [];
    newUnassigned[t] = all.filter(v => !used.includes(v));
  });

  return { groups:newGroups, unassigned:newUnassigned };
}

// Wire Load button
const fileInput = document.getElementById('fileFyt');
document.getElementById('btnLoad').onclick = ()=>{
  if(!fileInput) return;
  fileInput.value = '';
  fileInput.click();
};
if(fileInput){
  fileInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const buf = await f.arrayBuffer();
      const u8 = new Uint8Array(buf);
      const data = parseFytBytes(u8);
      // Validate against active profile: group names order and variable sets must match
      (function validateProfileMatch(){
        try{
          const parts = (data.sections && data.sections[0] && data.sections[0].parts) ? data.sections[0].parts : [];
          // Build expected union per display type from MACHINE_VAR
          const expectedUnion = {};
          TAB_ORDER.forEach(typeName=>{
            const mvMap = MACHINE_VAR[typeName]||{};
            expectedUnion[typeName] = new Set(Object.values(mvMap));
          });
          // Accumulate got union per display type (ignoring group names/order)
          const gotUnion = {};
          TAB_ORDER.forEach(t=> gotUnion[t]=new Set());
          parts.forEach(part=>{
            const dispType = machineToDisplayType(part.type) || part.type;
            const vs = part.vars || [];
            if(!(dispType in gotUnion)) gotUnion[dispType]=new Set();
            vs.forEach(v=> gotUnion[dispType].add(v));
          });
          // Compare sets for each known type
          TAB_ORDER.forEach(typeName=>{
            const exp = expectedUnion[typeName] || new Set();
            const got = gotUnion[typeName] || new Set();
            // check all expected present
            exp.forEach(v=>{ if(!got.has(v)) throw new Error(`Missing variable "${v}" for type "${typeName}".`); });
            // and no extras beyond expected
            got.forEach(v=>{ if(!exp.has(v)) throw new Error(`Unexpected variable "${v}" for type "${typeName}".`); });
          });
        }catch(e){
          alert('This FYT does not match the currently selected profile (union-of-vars check). ' + e.message);
          throw e;
        }
      })();

      // Populate top-level properties
      protocol = { description:data.description||"", repeat:data.repeat||2147483647, logic:data.logic||"", sections:data.sections||[{parts:[]}] };
      // Fill UI fields
      document.getElementById('desc').value = protocol.description;
      document.getElementById('logic').value = (protocol.logic && protocol.logic!=="") ? protocol.logic : '- not set -';
      document.getElementById('repeat').value = (protocol.repeat===2147483647) ? 'Infinitely times' : String(protocol.repeat);

      // Build groups & unassigned
      const rebuilt = buildGroupsFromLoaded(protocol);
      groups = rebuilt.groups;
      unassigned = rebuilt.unassigned;
      activeGroupId = groups[0]?.id || null;
      vmSelectedGroupId = activeGroupId;

      refreshUI();
      alert('FYT loaded successfully.');
    }catch(err){
      console.error(err);
      alert('Failed to load FYT: ' + err.message);
    }
  });
}

// Save: warn if group durations differ, then save JSON + FYT
$('#btnSave').onclick=()=>{
  if(!protocol){alert('Nothing to save.');return;}
  if(!isProtocolValid()){alert('All variables must be assigned and each type must have a group before saving.');return;}
  const data=buildProtocolJson(); if(!data) return;

  // Duration uniformity check
  const totals = groups.map(g=>g.phases.reduce((s,p)=>s+durationToSeconds(p.duration),0));
  const allSame = totals.every(t=>t===totals[0]);
  if(!allSame){
    const ok = confirm('Not all variable groups have the same time duration. Do you want to save protocol anyway?');
    if(!ok) return;
  }

  // Save JSON
  downloadText('protocol.json', JSON.stringify(data,null,2), 'application/json');

  // Save FYT
  const fytBytes = buildFytBinary(data);
  downloadBytes('protocol.fyt', fytBytes);
};

function createDefaultGroups(){
  groups=[];
  TAB_ORDER.forEach(type=>{
    groups.push({id:crypto.randomUUID(),type,name:type,vars:INVENTORY[type].slice(),phases:[]});
  });
  activeGroupId=groups[0].id; vmSelectedGroupId=groups[0].id;
}

/* ====== Helper for temperature edit values ====== */
function fmtForEdit(varType,val){ if(varType==='Temperature'){ return (Number(val)/10).toFixed(1); } return String(val);}

/* ====== Phase field builder kept earlier ====== */

</script>
</body>
</html>
